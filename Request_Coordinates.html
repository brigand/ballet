<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <title>Select Window Coordinates</title>
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <!--
    This app is in an ALPHA stage, meaning it may change in design.

    Remaining tasks:
      - TODO: support side docks
        TODO: support adjustments with move (m), shrink (i), and grow (I) combined with
              the directional letters hjkl for left, up, down, and right, respectively
        TODO: make inset and grow use aspect ratio scaling, such that when the size is the full screen,
              it's equal pixels on x/y, but at smaller sizes it prefers width over height
        TODO: make grow use the inverse of inset, such that combinations iI, Ii, and iiiIII are no-ops
        TODO: support setting an aspect ratio in both shrink and grow variants

      Administrative...
        TODO: refactor into multiple files
        TODO: build script to combine into a single, readable html file like we have now
        TODO: unit tests
        TODO: documentation
  -->
  <!--

    The UI is fully responsive, but an aspect ratio of 1.55:1 works well. Sizes at 1/3 screen

    1080:
      <body data-kmwidth="640" data-kmheight="413">
    1440:
      <body data-kmwidth="853" data-kmheight="550">
    4k:
      <body data-kmwidth="1044" data-kmheight="674">
  -->
  <body data-kmwidth="1044" data-kmheight="674">
    <style>
      /* Configuration */
      :root {
        /* Number of history frames to persist in the KM variable */
        --history-size: 40;
      }

      /* Theme settings; modify as you like */
      :root {
        --background: #444;
        --background-stripe: #555;
        --foreground: #fff5ee;
        --background-alt: #232935;
        --foreground-alt: #9ad7e9;
        --foreground-alt-muted: #a1bdc6;
        --moderate-contrast: rgba(164, 164, 164, 0.5);
        --error-color: #ff80ab;
      }

      /* Light theme, inherits from above */
      [data-theme='light'] {
        --background: #f8f8f8;
        --background-stripe: hsl(244, 17.7%, 81%);
        --moderate-contrast: rgba(100, 100, 100, 0.5);
        --foreground: #444444;
        --background-alt: #7bc2de;
        --foreground-alt: #8f89e4;
        --foreground-alt-muted: #bcb8f3;
      }

      /* Variables for math things */
      :root {
        /* We override this later in the JS, so just using a reasonable default for now */
        --screen-aspect: calc(16 / 9);

        /* our base is 600px wide viewport -> 16px font, so that's a scale of 37.5 */
        --font-scale: 37.5;

        /* We want the preview to maintain a 16:10 aspect ratio */
        --preview-space: calc(100vmin - 3em);
        --preview-width: var(--preview-space);
        --preview-height: calc(var(--preview-space) / var(--screen-aspect));

        --input-scale: 2.2;
      }

      /* If the viewport is in landscape, scale the preview on the other axis */
      @media screen and (min-aspect-ratio: 200/135) {
        :root {
          --preview-space: calc(100vh - 6.4em);
          --preview-height: var(--preview-space);
          --preview-width: calc(
            var(--preview-space) / (1 / var(--screen-aspect))
          );
        }
      }

      /*
        Viewport size -> font size -> everything size. Makes it behave more like scaling
        an image.
      */
      :root {
        --rt-font-size: 13px;

        --rt-font-size: calc(100vmin / var(--font-scale));
      }
    </style>
    <style>
      /* Generic CSS Resets */
      html,
      body {
        margin: 0;
        padding: 0;
        box-sizing: border-box;

        width: 100vw;
        height: 100%;
        overflow-x: hidden;
        overflow-y: visible;
      }

      input,
      button {
        margin: 0;
        border: 0;
        padding: 0;
        display: block;
        white-space: normal;
        background: none;
        line-height: 1;
        font-size: 1em;
        font-family: Arial;
      }

      *::selection,
      input::selection {
        background: var(--foreground-alt);
        color: white;
      }

      * {
        color: inherit;
        font-size: 1em;
        box-sizing: inherit;
        font-family: inherit;
      }
    </style>
    <section id="preview">
      <div id="preview_osx_bar"></div>
      <div id="preview_inner">
        <div id="preview_contents">
          <div class="menu_bar">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
          </div>
        </div>
        <pline class="preview_overflow hidden"></pline>
        <pline class="preview_overflow hidden"></pline>
        <pline class="preview_overflow hidden"></pline>
        <pline class="preview_overflow hidden"></pline>
      </div>
    </section>
    <form id="form">
      <input
        autocomplete="off"
        id="main-input"
        type="text"
        value="11"
        placeholder="1"
        autofocus
      />
      <div id="error" class="hidden"></div>
      <button type="submit" id="submit">âž¡</button>
    </form>
    <div id="popup" class="hidden"><div class="contents"></div></div>

    <script>
      {
        window.$dbg = {};

        const input = document.querySelector('#main-input');
        const preview = document.querySelector('#preview');
        const preview_inner = document.querySelector('#preview_inner');
        const preview_osx_bar = document.querySelector('#preview_osx_bar');
        const form = document.querySelector('#form');
        const error_el = document.querySelector('#error');
        const popup = document.querySelector('#popup');
        const popup_contents = document.querySelector('#popup .contents');
        const preview_contents = document.querySelector('#preview_contents');
        const preview_overflows = [
          document.querySelector('.preview_overflow'),
          document.querySelector('.preview_overflow:nth-of-type(2)'),
          document.querySelector('.preview_overflow:nth-of-type(3)'),
          document.querySelector('.preview_overflow:nth-of-type(4)'),
        ];

        let screen = null;

        window.addEventListener('error', (event) => {
          setTimeout(() => {
            let html = `Please report this error here https://git.io/fhLs1.<br>\n`;
            html += '<pre class="uncaught">';

            if (event.error.stack) {
              let s = String(event.error.stack);
              if (!s.includes(event.error.message)) {
                s = `${event.error.message}\n${s}`;
              }
              html += html_escape(s);
            } else {
              html += html_escape(String(event.error));
            }
            html += '</pre>';
            setPopupHtml(html);
          }, 5);
        });

        let inputHistory;

        const init = () => {
          // Clear out the variables
          set_km_vars([[null, null], [null, null]]);

          // TODO: implement side margins, for side positioned docks
          if (window.KeyboardMaestro) {
            screen = {
              width: window.KeyboardMaestro.Calculate(
                'SCREENVISIBLE(Front, WIDTH)',
              ),
              height: window.KeyboardMaestro.Calculate(
                'SCREENVISIBLE(Front, HEIGHT)',
              ),
              full_width: window.KeyboardMaestro.Calculate(
                'SCREEN(Front, WIDTH)',
              ),
              full_height: window.KeyboardMaestro.Calculate(
                'SCREEN(Front, HEIGHT)',
              ),
              margin: {},
            };

            screen.margin_top =
              window.KeyboardMaestro.Calculate('SCREENVISIBLE(Front, TOP)') -
              window.KeyboardMaestro.Calculate('SCREEN(Front, TOP)');
            screen.margin_bottom =
              window.KeyboardMaestro.Calculate('SCREEN(Front, BOTTOM)') -
              window.KeyboardMaestro.Calculate('SCREENVISIBLE(Front, BOTTOM)');

            setTimeout(() => {
              setPopupHtml(html_escape(JSON.stringify(screen)));
            }, 1000);
          } else {
            // emulate the screen size when not in KM
            // screen = { full_width: 1920, full_height: 1080 };
            screen = { full_width: 2560, full_height: 1440 };
            // screen = { full_width: 3840, full_height: 2160 };

            screen.margin_top = 20;
            screen.margin_bottom = 0;
            screen.width = screen.full_width;
            screen.height =
              screen.full_height - screen.margin_top - screen.margin_bottom;
          }

          inputHistory = new InputHistory(get_km_var('Coord_History'));

          $dbg.inputHistory = inputHistory;

          // Restore last executed value
          const last = inputHistory.get();
          if (last) {
            input.value = last.value;
          }

          input.addEventListener(
            'input',
            () => {
              update({});
            },
            false,
          );

          input.addEventListener(
            'keydown',
            (event) => {
              if (event.key === 'ArrowUp') {
                const item = inputHistory.goBack().get();
                input.value = item.value;
                update({});
              } else if (event.key === 'ArrowDown') {
                const item = inputHistory.goForward().get();
                input.value = item.value;
                update({});
              }
            },
            false,
          );

          {
            // We can't use margins because they'd be percentags of width
            const mt_p = screen.margin_top / screen.full_height;
            const mb_p = screen.margin_bottom / screen.full_height;
            const both = mt_p + mb_p;
            preview_inner.style.position = 'relative';
            preview_inner.style.height = (1 - both) * 100 + '%';
            preview_osx_bar.style.height = mt_p * 100 + '%';

            // Let's make sure we have the right aspect ratio; otherwise things won't work correctly.
            const full_aspect = screen.full_width / screen.full_height;

            document.documentElement.style.setProperty(
              '--screen-aspect',
              full_aspect,
            );
          }

          saveState();
          update({});
          input.select();
        };

        // Keep track of any values we need between runs
        const saveState = () => {
          inputHistory.truncate(Number(getCssVar('--history-size')));
          set_km_var(
            'Coord_History',
            JSON.stringify(
              inputHistory.truncate(Number(getCssVar('--history-size'))),
            ),
          );
        };

        // Track variables in a Map so we can display them when not running inside KeyboardMaestro
        const var_store = new Map();

        form.addEventListener('submit', (event) => {
          event.preventDefault();

          const { coordinates, error } = update();

          if (error) {
            alert(
              `The input is invalid.\nPlease correct it or press Escape to quit:\n\n${error}`,
            );
            return;
          }

          set_km_vars(coordinates);

          inputHistory.persistEphemeral();
          saveState();

          if (window.KeyboardMaestro) {
            window.KeyboardMaestro.Submit('OK');
          } else {
            popup.classList.toggle('hidden', false);
            let html =
              html_escape(`If in KeyboardMaestro, we'd set these variables`) +
              '<dl>';
            for (const [k, v] of var_store) {
              html +=
                `<dt>` + html_escape(k) + `</dt><dd>${html_escape(v)}</dd>\n`;
            }
            html += '</dl>';

            setPopupHtml(html);
          }
        });

        const setPopupHtml = (html) => {
          if (html) {
            popup.classList.toggle('hidden', false);
            popup_contents.innerHTML = html;
          } else {
            popup.classList.toggle('hidden', true);
            popup_contents.innerHTML = '';
          }
        };

        window.addEventListener('click', () => {
          setPopupHtml(null);
        });

        const set_km_var = (key, value) => {
          let serialized = value == null ? '' : value;

          if (typeof value === 'number' && Number.isFinite(value)) {
            serialized = value.toFixed('.000260417'.length - 1);
          }

          var_store.set(key, serialized);
          if (window.KeyboardMaestro) {
            window.KeyboardMaestro.SetVariable(key, serialized);
          }
        };

        const get_km_var = (key) => {
          if (window.KeyboardMaestro) {
            return window.KeyboardMaestro.GetVariable(key) || null;
          } else {
            return var_store.get(key) || null;
          }
        };

        const set_km_vars = (coords) => {
          const [[x1, y1], [x2, y2]] = coords;

          set_km_var('Coord_X_1', x1);
          set_km_var('Coord_Y_1', y1);
          set_km_var('Coord_X_2', x2);
          set_km_var('Coord_Y_2', y2);
          set_km_var('Coord_JSON', JSON.stringify(coords));
        };

        const update = (params) => {
          setPopupHtml(null);

          const { error, ops } = parse_input();

          inputHistory.setEphermeral(input.value);

          error_el.classList.toggle('hidden', !error);
          error_el.textContent = error ? String(error) : '';

          if (ops && !error) {
            // You can uncomment this to see how the input gets parsed.
            // console.log(success.map(x => x.debug()).join('\n'));
            let coordinates = parsed_to_coordinates(ops);

            const overflow = check_coord_overflow(coordinates);
            preview_overflows[0].classList.toggle('hidden', !overflow.top);
            preview_overflows[1].classList.toggle('hidden', !overflow.right);
            preview_overflows[2].classList.toggle('hidden', !overflow.bottom);
            preview_overflows[3].classList.toggle('hidden', !overflow.left);

            coordinates = constrain_coords(coordinates);

            preview_contents.style.opacity = '1';
            preview_contents.style.left = coordinates[0][0] * 100 + '%';
            preview_contents.style.top = coordinates[0][1] * 100 + '%';
            preview_contents.style.right = 100 - coordinates[1][0] * 100 + '%';
            preview_contents.style.bottom = 100 - coordinates[1][1] * 100 + '%';

            return { coordinates, error };
          } else {
            preview_contents.style.opacity = '0.1';
            return { coordinates: null, error };
          }
        };

        const parse_input = (value = input.value) => {
          let current = 0;
          const ops = [];
          const buf = new StringBuf(value);
          while (!buf.is_end()) {
            const first = buf.take();

            if (first === ' ') {
              continue;
            }

            const DIR_MAP = new Map([
              ['h', 'left'],
              ['j', 'down'],
              ['k', 'up'],
              ['l', 'right'],
            ]);

            if (DIR_MAP.has(first)) {
              const key = DIR_MAP.get(first);
              const opts = {
                up: false,
                right: false,
                down: false,
                left: false,
                count: 1,
              };
              opts[key] = true;

              do {
                opts.count += 1;
              } while (buf.take_match(first));

              ops.push(['Move', opts]);
              continue;
            }

            if (first === 'i' || first === 'I') {
              let any_directional = false;
              const data = {
                up: null,
                right: null,
                down: null,
                left: null,
                count: 1,
              };

              while (true) {
                if (!any_directional && first === 'i' && buf.take_match('i')) {
                  data.count += 1;
                } else if (
                  !any_directional &&
                  first === 'I' &&
                  buf.take_match('I')
                ) {
                  data.count += 1;
                } else if (DIR_MAP.has(buf.peek_at())) {
                  any_directional = true;

                  const key = DIR_MAP.get(buf.take());
                  if (data[key]) {
                    data.count += 1;
                  } else {
                    data[key] = true;
                  }
                } else {
                  break;
                }
              }

              if (data.up == null) {
                data.up = !any_directional;
              }
              if (data.right == null) {
                data.right = !any_directional;
              }
              if (data.down == null) {
                data.down = !any_directional;
              }
              if (data.left == null) {
                data.left = !any_directional;
              }

              if (first === 'i') {
                ops.push(['Inset', data]);
              } else {
                ops.push(['Outset', data]);
              }

              continue;
            }
            if (first === 'a' || first === 'A') {
              const dir = first === 'a' ? 'AspectShrink' : 'AspectGrow';
              let w = null;
              let h = null;

              // parsing any of...
              //   a1 -> [1, 1]
              //   a1:2 -> [1, 2]
              //   a16:9 -> [16, 9]
              // for any number of digits in each part
              while (!buf.is_end()) {
                if (is_digit(buf.peek_at(0))) {
                  while (true) {
                    const n2 = buf.peek_at(0);
                    if (is_digit(n2)) {
                      if (h === null) {
                        w = w || 0;
                        w = w * 10 + parseInt(buf.take(), 10);
                      } else {
                        h = h * 10 + parseInt(buf.take(), 10);
                      }
                    } else {
                      break;
                    }
                  }
                } else if (buf.peek_at(0) === ':') {
                  if (w === null) {
                    return {
                      error: `Must specify the width part of the aspect ratio before ':'`,
                      index: buf.offset,
                    };
                  }
                  buf.take(1);
                  h = 0;
                } else {
                  break;
                }
              }

              if (w !== null) {
                // either null or 0. Would be 0 in the case of `a1:`,
                // which is a WIP value
                if (!h) {
                  h = w;
                }

                ops.push([dir, { w, h }]);
              }
              continue;
            }

            if (first === 'f') {
              ops.push(['FlipX', true]);
              continue;
            }

            if (first === 'F') {
              ops.push(['FlipY', true]);
              continue;
            }

            if (first === 'r') {
              ops.push(['Rotate', 90]);
              continue;
            }

            if (first === 'R') {
              ops.push(['Rotate', -90]);
              continue;
            }

            if (first === 's') {
              ops.push(['SquareShort', true]);
              continue;
            }

            if (first === 'S') {
              ops.push(['SquareLong', true]);
              continue;
            }

            const next = buf.peek_at(0);

            if (is_digit(first)) {
              if (next === '/') {
                buf.take(1);
                const denom = buf.take(1);
                if (!is_digit(denom)) {
                  return {
                    index: buf.offset - 1,
                    error: `Expected a digit after the /`,
                  };
                }

                ops.push(['Fraction', [parseFloat(first), parseFloat(denom)]]);
              } else if (next === '.') {
                buf.take(1);
                const dec = buf.take(1);

                if (!is_digit(dec)) {
                  return {
                    index: buf.offset - 1,
                    error: `Expected a digit after the '.'`,
                  };
                }

                ops.push(['EdgeOffset', parseFloat(first + '.' + dec)]);
              } else {
                ops.push(['EdgeOffset', parseFloat(first)]);
              }
            } else {
              return {
                index: buf.offset - 1,
                error: `The character "${first}" has no meaning in this context.`,
              };
            }
          }

          // if (!buf.is_end()) {
          //   return { error: `Parsing completed but there were extra characters: ${JSON.stringify(buf.take(1000))}` };
          // }

          return { ops, error: null };
        };

        const scale_number = (num) => {
          // 1 => 0.0
          // 9 => 1.0
          return (num - 1) / 8;
        };

        const parsed_to_coordinates = (parsed) => {
          const buf = new TokenBuf(parsed);

          let coordinates = null;

          if (buf.peek_type() === 'EdgeOffset' || buf.items.length === 0) {
            let item;
            let offsets = [];
            while ((item = buf.take_value('EdgeOffset'))) {
              offsets.push(item);
            }

            coordinates = num_sequence_to_coordinates(offsets);
          } else if (buf.peek_type() === 'Fraction') {
            const [num, denom] = buf.take_value();

            coordinates = fraction_to_coordinates(num, denom);
          } else {
            // e.g. allows 'i' to be synonymous with '1i'
            return parsed_to_coordinates([['EdgeOffset', 1], ...parsed]);
          }

          while (!buf.is_end()) {
            const is_inset = buf.peek_type() === 'Inset';
            const is_outset = buf.peek_type() === 'Outset';
            const is_move = buf.peek_type() === 'Move';
            if (is_inset || is_outset || is_move) {
              const opts = buf.take_value();

              // If you want to play with the base or exponent... in python:
              //   >>> b = 20.0; exp = 2; [int(b * exp ** i) for i in range(0, 5)]
              //   [20, 40, 80, 160, 320]
              const screen_y_percent = 20 / 1080;
              const unit = screen_y_percent * screen.full_height;

              // This works out to opts.count=11 reducing us by 90% of the screen width
              const pixels = unit * 1.54 ** opts.count;

              if (is_move) {
                coordinates = move_coordinates(
                  opts,
                  coordinates,
                  ...pixels_to_percent(pixels),
                );
              } else {
                coordinates = grow_coordinates(
                  { ...opts, scale: is_inset ? -1 : 1 },
                  coordinates,
                  ...pixels_to_percent(pixels),
                );
              }
            } else if (buf.peek_type() === 'Rotate') {
              const deg = buf.take_value();

              coordinates = rotate_coordinates_percent(coordinates, deg);
            } else if (buf.take_value('FlipX')) {
              coordinates = flip_coordinates_x(coordinates);
            } else if (buf.take_value('FlipY')) {
              coordinates = flip_coordinates_y(coordinates);
            } else {
              throw new Error(`Unexpected token ${buf.take(1)}`);
            }

            // TODO: implemnt SquareShort: reduce the long side until the screen pixels are a square
            // TODO: implemnt SquareLong: expand the short side until the screen pixels are a square
          }

          return coordinates;
          // TODO: implement inset
          // TODO: implement rotate
          // TODO: implement flip
        };

        const rotate_coordinates_percent = (coords, deg) => {
          const [x1, y1] = rotate(0.5, 0.5, coords[0][0], coords[0][1], -deg);
          const [x2, y2] = rotate(0.5, 0.5, coords[1][0], coords[1][1], -deg);
          return normalize_coords([[x1, y1], [x2, y2]]);
        };

        const flip_coordinates_x = ([[x1, y1], [x2, y2]]) => {
          return normalize_coords([[1 - x2, y1], [1 - x1, y2]]);
        };

        const flip_coordinates_y = ([[x1, y1], [x2, y2]]) => {
          return normalize_coords([[x1, 1 - y2], [x2, 1 - y1]]);
        };

        const normalize_coords = (coords) => {
          const c = (x) => Math.min(1, Math.max(0, x));
          return [
            [
              c(Math.min(coords[0][0], coords[1][0])),
              c(Math.min(coords[0][1], coords[1][1])),
            ],
            [
              c(Math.max(coords[0][0], coords[1][0])),
              c(Math.max(coords[0][1], coords[1][1])),
            ],
          ];
        };

        const rotate = (cx, cy, x, y, angle) => {
          const radians = (Math.PI / 180) * angle;
          const cos = Math.cos(radians);
          const sin = Math.sin(radians);
          const nx = cos * (x - cx) + sin * (y - cy) + cx;
          const ny = cos * (y - cy) - sin * (x - cx) + cy;
          return [nx, ny];
        };

        const cond_map = (cond, value, mapper) => {
          if (cond) {
            return mapper(value);
          }
          return value;
        };

        const move_coordinates = (opts, coords, x_percent, y_percent) => {
          let scale_left = 0;
          let scale_top = 0;
          let scale_right = 0;
          let scale_bottom = 0;

          if (opts.left) {
            scale_left = -1;
            scale_right = -1;
          }

          if (opts.right) {
            scale_left = 1;
            scale_right = 1;
          }
          if (opts.up) {
            scale_top = -1;
            scale_bottom = -1;
          }
          if (opts.down) {
            scale_top = 1;
            scale_bottom = 1;
          }

          return [
            [
              coords[0][0] + x_percent * scale_left,
              coords[0][1] + y_percent * scale_top,
            ],
            [
              coords[1][0] + x_percent * scale_right,
              coords[1][1] + y_percent * scale_bottom,
            ],
          ];
        };

        const check_coord_overflow = (coords) => {
          let top = false;
          let right = false;
          let bottom = false;
          let left = false;

          if (coords[0][0] < 0) {
            left = true;
          }

          if (coords[1][0] > 1) {
            right = true;
          }

          if (coords[0][1] < 0) {
            top = true;
          }
          if (coords[1][1] > 1) {
            bottom = true;
          }

          return {
            top,
            right,
            bottom,
            left,
            any: top || right || bottom || left,
          };
        };

        const constrain_coords = (coords) => {
          const xs = [...coords[0], ...coords[1]].map((x) =>
            Math.max(0, Math.min(1, x)),
          );

          return [[xs.shift(), xs.shift()], [xs.shift(), xs.shift()]];
        };

        const grow_coordinates = (opts, coords, x_percent, y_percent) => {
          if (typeof opts.scale === 'number') {
            x_percent *= opts.scale;
            y_percent *= opts.scale;
          }

          return [
            [
              cond_map(opts.left, coords[0][0], (v) => v - x_percent),
              cond_map(opts.up, coords[0][1], (v) => v - y_percent),
            ],
            [
              cond_map(opts.right, coords[1][0], (v) => v + x_percent),
              cond_map(opts.down, coords[1][1], (v) => v + y_percent),
            ],
          ];
        };

        const num_sequence_to_coordinates = (items) => {
          const count = items.length;

          // No items? Then edge to edge
          if (count === 0) {
            return num_sequence_to_coordinates([1]);
          }

          // With just one number, we'll treat e.g. '4' as '44', hitting the following conditional
          if (count === 1) {
            if (items[0] < 5) {
              return num_sequence_to_coordinates([items[0], items[0]]);
            } else {
              // but don't make a 0 sized shape
              return num_sequence_to_coordinates([items[0], 1, 1, 1]);
            }
          }

          /* With two numbers, copy the offset from the top left to the bottom right,
                       resulting in a centered output.
                    */
          if (count === 2) {
            return [
              [scale_number(items[0]), scale_number(items[1])],
              [
                1 - scale_number(items[0] < 5 ? items[0] : 1),
                1 - scale_number(items[1] < 5 ? items[1] : 1),
              ],
            ];
          }

          /*
                      We're missing y2, so just default y2 to 1-y1.
                      TODO: is this really the most sensible option?
                    */
          if (count === 3) {
            return [
              [scale_number(items[0]), scale_number(items[1])],
              [
                1 - scale_number(items[2]),
                1 - scale_number(items[1] < 5 ? items[1] : 1),
              ],
            ];
          }

          // perfect case, where we have ((x, y), (x, y))
          if (count === 4) {
            return [
              [scale_number(items[0]), scale_number(items[1])],
              [1 - scale_number(items[2]), 1 - scale_number(items[3])],
            ];
          }
        };

        const fraction_to_coordinates = (num, denom) => {
          if (!num) {
            throw new Error(`The numerator must be between 1 and 9.`);
          }

          const by_denom = {
            1: [[0, 0, 1, 1]],
            2: [
              // horizontal 1:1
              [0, 0, 1 / 2, 1],
              [1 / 2, 0, 2 / 2, 1],
            ],
            3: [
              // horizontal 1:1:1
              [0, 0, 1 / 3, 1],
              [1 / 3, 0, 2 / 3, 1],
              [2 / 3, 0, 3 / 3, 1],
            ],
            4: [
              // 2x2 grid
              [0, 0, 1 / 2, 1 / 2], // top left
              [1 / 2, 0, 2 / 2, 1 / 2], // top right
              [1 / 2, 1 / 2, 2 / 2, 2 / 2], // bottom right
              [0, 1 / 2, 1 / 2, 2 / 2], // bottom left
            ],
            6: {
              // 3 wide, 2 tall grid
              // TODO: implement this
            },
          };

          const values = by_denom[denom];
          // TODO: handle invalid denom with an error

          if (!values) {
            throw new Error(
              `Only the denominators (${by_denom.join(',')}) are supported.`,
            );
          }

          const index = (num - 1) % values.length;
          const [x1, y1, x2, y2] = values[index];

          let coords = [[x1, y1], [x2, y2]];

          // 3/2 is short for 1/2R
          const excess = Math.floor((num - 1) / denom);

          if (excess) {
            coords = rotate_coordinates_percent(coords, excess * 90);
          }

          return coords;
        };

        function is_digit(x) {
          return /[0-9]/.test(x);
        }

        class Option {
          static Some(x) {
            return new Option('Some', x);
          }
          static None() {
            return new Option('None', null);
          }

          constructor(variant, value) {
            this.variant = variant;
            this.value = value;
          }

          is_some() {
            return this.variant === 'Some';
          }

          is_none() {
            return !this.is_some;
          }

          unwrap() {
            if (this.is_some()) {
              return this.value;
            }
            throw new Error('None.unwrap() was called');
          }

          debug() {
            if (this.is_some()) {
              return `Some(${JSON.stringify(this.value)})`;
            }
            return `None`;
          }
        }

        const pixels_to_percent = (pixels) => {
          const x = pixels / screen.width;
          const y = pixels / screen.height;

          return [x, y];
        };

        class Buf {
          constructor(arg) {
            this.items = [...arg];
            this.index = 0;
          }

          take(count = 1) {
            this.index += count;
            return this.items.slice(this.index - count, this.index);
          }

          peek_n(count = 1) {
            return this.items.slice(this.index, this.index + count);
          }

          peek_at(offset = 0) {
            return this.items[this.index + offset];
          }

          is_end() {
            return this.index >= this.items.length;
          }
        }

        class StringBuf extends Buf {
          constructor(str) {
            super(str);
          }

          take(count = 1) {
            return super.take(count).join('');
          }

          take_match(chars) {
            const count = chars.length;

            if (this.peek_n(count) === chars) {
              return super.take(count).join('');
            }

            return null;
          }

          peek_n(count = 1) {
            return super.peek_n(count).join('');
          }
        }

        class TokenBuf extends Buf {
          peek_type(offset = 0) {
            const x = this.peek_at(offset);
            return x ? x[0] : null;
          }

          peek_value(offset = 0) {
            const x = this.peek_at(offset);
            return x ? x[1] : null;
          }

          take_value(for_type) {
            if (for_type && this.peek_type() !== for_type) {
              return null;
            }

            return this.take()[0][1];
          }
        }

        class InputHistory {
          constructor(historyArg) {
            // 0 is the latest item
            this.offset = 0;

            // For editing a history line, we need to store where
            // in the history they were when the change happened,
            // and what the value was.
            this.ephermeral = new Map();

            // If we're on an ephemeral history item, since both share
            // the same .offset value.
            this.isEphemeral = false;

            let items = historyArg;

            // Attempt to deserialize the items array. If it doesn't exactly match
            // our expectations, then we'll ignore the input.
            let valid = false;
            if (typeof items === 'string') {
              try {
                items = JSON.parse(items);
              } catch (e) {
                // do nothing
              }
            }

            if (Array.isArray(items)) {
              items = items.map((item) =>
                item && typeof item.value === 'string'
                  ? {
                      value: item.value,
                    }
                  : null,
              );

              valid = items.every(Boolean);
            } else {
              valid = false;
            }

            if (!valid) {
              items = [];
            }

            this.items = items;
          }

          truncate(size) {
            this.items = this.items.slice(0, size);
            this.offset = Math.max(
              0,
              Math.min(this.offset, this.items.length - 1),
            );
            return this.mapSetEphemeral((k, v) =>
              k < this.items.length ? [k, v] : null,
            );
          }

          get() {
            if (this.isEphemeral) {
              return this.ephermeral.get(this.offset);
            } else {
              return this.items[this.offset];
            }
          }

          mapSetEphemeral(modifier) {
            const new_map = new Map();
            for (const [offset, value] of this.ephermeral) {
              const updated = modifier(offset, value);
              if (updated && updated.length === 2) {
                new_map.set(updated[0], updated[1]);
              }
            }
            this.ephermeral = new_map;
            return this;
          }

          persistEphemeral() {
            if (!this.isEphemeral && this.offset === 0) {
              return this;
            }

            this.isEphemeral = false; // the .get() needs this

            const newest = this.items[0];
            const current = this.items[this.offset];
            const eph = this.ephermeral.get(this.offset);
            this.ephermeral.delete(this.offset);

            if (!eph && newest && current.value !== newest.value) {
              this.add(current.value);
            } else if (eph) {
              // avoid the sequantial duplicates
              const a = newest && newest.value === eph.value;
              const b = current && current.value === eph.value;
              this.add(eph.value);
            }

            return this;
          }

          add(value) {
            this.items.unshift({ value });
            return this.mapSetEphemeral((k, v) => [k + 1, v]);
          }

          setEphermeral(value) {
            const current = this.get();

            if (!this.isEphemeral && current && current.value === value) {
              return;
            }

            this.ephermeral.set(this.offset, { value, ephermeral: true });
            this.isEphemeral = true;
            return this;
          }

          goBack() {
            if (this.isEphemeral) {
              // is there a non-ephemeral item to return to?
              if (this.items.length) {
                this.isEphemeral = false;
              }
              // keep the same offset
            } else if (this.offset < this.items.length - 1) {
              this.offset += 1;

              if (this.ephermeral.get(this.offset)) {
                this.isEphemeral = true;
              }
            }
            return this;
          }

          goForward() {
            if (this.offset > 0) {
              if (!this.isEphemeral && this.ephermeral.has(this.offset)) {
                this.isEphemeral = true;
              } else {
                this.offset -= 1;
                this.isEphemeral = false;
              }
            } else {
              this.isEphemeral = this.ephermeral.has(this.offset);
            }

            return this;
          }

          toJSON() {
            return this.items;
          }
        }

        const html_escape = (str) =>
          str
            .replace(/&/g, '&amp;')
            .replace(/>/g, '&gt;')
            .replace(/</g, '&lt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/`/g, '&#96;');

        init();

        // e.g. getCssVar('--some-var')
        function getCssVar(propertyName, element = null) {
          return getComputedStyle(
            element || document.documentElement,
          ).getPropertyValue(propertyName);
        }
      }
    </script>

    <style>
      /* Our custom styles */
      html,
      body {
        background: var(--background);
        color: var(--foreground);
        font-family: Arial, Helvetica, sans-serif;
      }

      body {
        font-size: var(--rt-font-size);
        display: flex;
        flex-direction: column;
      }

      #form {
        display: flex;
      }

      #main-input {
        letter-spacing: 0.75em;
        font-family: Monaco, 'Courier New', monospace;
        flex: 1 1 auto;
        font-size: calc(1em * var(--input-scale));
        line-height: 1em;
        padding: 0.5em 0.8em;
        background: var(--background-alt);
        width: 100%;
      }

      #main-input:focus {
        outline: none;
        box-shadow: inset 0 0 2.5px 1px var(--foreground-alt);
      }

      #main-input::-webkit-input-placeholder {
        color: var(--moderate-contrast);
      }

      #buttons {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        flex: 0 0 auto;
      }

      #submit {
        font-size: 3em;
        width: 1.8em;
        background: var(--background-alt);
      }

      #submit:focus {
        outline: none;
        box-shadow: inset 0 0 2.5px 1px var(--foreground-alt);
      }

      #preview {
        width: var(--preview-width);
        height: var(--preview-height);
        overflow: hidden;
        flex: 0 0 auto;
        display: flex;
        flex-direction: column;
        margin: auto auto;

        background-image: var(--bg-pattern);
        box-shadow: 0 0 0 2px var(--moderate-contrast);
        border-radius: 0.5em;
      }

      #preview_osx_bar {
        --bg-color-1: hsla(0, 0%, 65%, 0.5);
        background: linear-gradient(
            0,
            var(--bg-color-1) 0%,
            var(--bg-color-1) 100%
          ),
          var(--background);

        box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.3),
          0 0 1.5px 2px rgba(220, 220, 220, 0.7);
      }

      #preview_inner {
        position: relative;
        flex: 0 1 auto;
        align-self: stretch;
        justify-self: stretch;
      }

      #preview_contents {
        overflow: hidden;
        position: absolute;
        --tt: 0.08s;
        transition: top var(--tt), right var(--tt), bottom var(--tt),
          left var(--tt), width var(--tt), height var(--tt);
        transition-timing-function: ease-out;
        box-shadow: inset 0 0 0 1px var(--moderate-contrast),
          inset 0 0 0 2px var(--foreground);
        background: var(--background-alt);
        border-radius: 0.5em;
      }

      #preview_contents .menu_bar {
        background: whitesmoke;
        padding: 0.2em 0.6em;
        box-shadow: 0 0 2.5px black;
        display: flex;
      }

      #preview_contents .dot {
        font-size: 0.53em;
        width: 1em;
        height: 1em;
        margin-right: 0.5em;
        border-radius: 50%;
        box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);

        --red: #f53b3d;
        --yellow: #f8b526;
        --green: #29c332;
      }

      #preview_contents .dot:nth-of-type(1) {
        background-color: var(--red);
      }

      #preview_contents .dot:nth-of-type(2) {
        background-color: var(--yellow);
      }

      #preview_contents .dot:nth-of-type(3) {
        background-color: var(--green);
      }

      .preview_overflow {
        --margin: 1.6em;

        width: 3px;
        height: 3px;
        position: absolute;
        background: #cc2244;
        box-shadow: inset 0 0 0 3px var(--color), 0 0 3px 1px #990024;
        pointer-events: none;
        transition: opacity 0.15s;
        z-index: 100;
      }

      .preview_overflow:nth-of-type(1) {
        /* top */
        top: 0;
        left: var(--margin);
        right: var(--margin);
        width: auto;
      }

      .preview_overflow:nth-of-type(2) {
        /* right */
        top: var(--margin);
        bottom: var(--margin);
        right: 0;
        height: auto;
      }

      .preview_overflow:nth-of-type(3) {
        /* bottom */
        bottom: 0;
        left: var(--margin);
        right: var(--margin);
        width: auto;
      }

      .preview_overflow:nth-of-type(4) {
        /* left */
        top: var(--margin);
        bottom: var(--margin);
        left: 0;
        height: auto;
      }

      #form {
        position: relative;
      }

      #error {
        position: absolute;
        bottom: calc(100% + 2px);
        right: 0;
        background: var(--foreground);
        color: var(--error-color);
        line-height: 1.6;
        padding: 0.2em 0.6em;
      }

      .hidden {
        opacity: 0;
        pointer-events: none;
      }

      #popup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-height: 4em;
        min-width: 14em;
        max-width: 92vw;
        max-height: 92vh;
        overflow-y: auto;
        overflow-x: visible;
        display: flex;
        flex-direction: column;
        background: var(--foreground);
        color: var(--background);
        padding: 0.6em;
        box-shadow: 0 0 3px 1px var(--moderate-contrast);
        border-radius: 3px;
      }

      dl,
      dd,
      dt {
        font-family: 'Courier New', Courier, monospace;
      }

      dt {
        margin-top: 0.5em;
        margin-bottom: 0.3em;
      }

      #popup .contents {
        margin: auto;
      }

      .uncaught {
        font-size: 16px;
        color: var(--error-color);
        font-family: 'Courier New', Courier, monospace;
        white-space: pre-wrap;
        max-height: 14em;
        overflow-y: auto;
        overflow-x: visible;
        width: 95%;
        max-width: 32em;
        padding: 0.6em;
        box-shadow: inset 0 0 1px 2px black;
        word-break: break-all;
      }

      a,
      a:hover,
      a:active,
      a:focus {
        color: var(--foreground-alt);
      }

      a:hover,
      a:active,
      a:focus {
        text-shadow: 0 0 1px rgba(0, 0, 0, 0.1);
      }

      :root {
        --bg-pattern: repeating-linear-gradient(
          45deg,
          transparent 1em,
          var(--background-stripe) 1em,
          var(--background-stripe) 1.3333em,
          transparent 1.3333em,
          transparent 2em
        );
      }
    </style>
  </body>
</html>
